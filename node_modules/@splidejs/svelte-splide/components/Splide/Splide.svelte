<script >import { getSlides, isEqualDeep, isEqualShallow, merge } from '../../utils';
import { Splide } from '@splidejs/splide';
import { afterUpdate, createEventDispatcher, onMount } from 'svelte';
import { bind } from './bind';
/**
 * The ID for the slider root element.
 */
export let id = undefined;
/**
 * Splide options. Do not change readonly options after mount.
 */
export let options = {};
/**
 * The splide instance.
 */
export let splide = undefined;
/**
 * An object with extensions.
 */
export let extensions = undefined;
/**
 * A transition component.
 */
export let transition = undefined;
/**
 * Determines whether to wrap the track by the slider element or not.
 */
export let hasSliderWrapper = false;
/**
 * A dispatcher function.
 * The `createEventDispatcher` type assertion does not accept a type alias.
 * If specified, the svelte kit fails to generate a type of `events` and it will be `CustomEvent<any>`.
 * Also, the svelte action does not provide the way to specify event types.
 */
const dispatch = createEventDispatcher();
/**
 * The root element.
 */
let root;
/**
 * Holds the previous slide elements.
 */
let prevSlides;
/**
 * Holds the previous options.
 */
let prevOptions = merge({}, options);
/**
 * Updates splide options only when they have difference with previous options.
 */
$: if (splide && !isEqualDeep(prevOptions, options)) {
    splide.options = options;
    prevOptions = merge({}, prevOptions);
}
onMount(() => {
    splide = new Splide(root, options);
    bind(splide, dispatch);
    splide.mount(extensions, transition);
    prevSlides = getSlides(splide);
    return () => splide.destroy();
});
afterUpdate(() => {
    if (splide) {
        const newSlides = getSlides(splide);
        if (!isEqualShallow(prevSlides, newSlides)) {
            splide.refresh();
            prevSlides = newSlides.slice();
        }
    }
});
/**
 * Moves the slider by the specified control.
 *
 * @param control - A control pattern.
 */
export function go(control) {
    splide?.go(control);
}
/**
 * Syncs the slider with another Splide.
 *
 * @param target - A target splide instance to sync with.
 */
export function sync(target) {
    splide?.sync(target);
}
</script>

<svelte:options accessors/>

<div
  { id }
  class={ `splide ${ $$props.class || '' }`.trim() }
  bind:this={ root }
>
  { #if hasSliderWrapper }
    <slot name="before-slider"/>
  { /if  }

  { #if hasSliderWrapper }
    <div class="splide__slider">
      <slot name="before-track"/>

      <div class="splide__track">
        <ul class="splide__list">
          <slot/>
        </ul>
      </div>

      <slot name="after-track"/>
    </div>
  { :else }
    <slot name="before-track"/>

    <div class="splide__track">
      <ul class="splide__list">
        <slot/>
      </ul>
    </div>

    <slot name="after-track"/>
  { /if  }

  { #if hasSliderWrapper }
    <slot name="after-slider"/>
  { /if  }
</div>
